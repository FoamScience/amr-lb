<!doctype html><html lang=en>
<head>
<meta name=generator content="Hugo 0.89.4">
<meta charset=utf-8>
<title>AMR-LB</title>
<meta name=apple-mobile-web-app-capable content="yes">
<meta name=apple-mobile-web-app-status-bar-style content="black-translucent">
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400&family=Fira+Sans&display=swap" rel=stylesheet>
<link href=css/interactive-image.min.css rel=stylesheet>
<script type=text/javascript src=js/jquery.min.js></script>
<script type=text/javascript src=js/interactive-image.min.js></script>
<link rel=stylesheet type=text/css href=js/tikzjax/fonts.css>
<script src=js/tikzjax/tikzjax.js></script>
<link rel=stylesheet href=/amr-lb/reveal-js/reset.css>
<link rel=stylesheet href=/amr-lb/reveal-js/reveal.css><link rel=stylesheet href=/amr-lb/reveal-js/theme/black.css id=theme>
<link rel=stylesheet href=/amr-lb/highlight-js/dracula.min.css><link rel=stylesheet href=/amr-lb/stylesheets/custom.css id=custom_css>
</head>
<body>
<div class=reveal>
<div class=slides>
<section><h2 id=towards--dynamically--load-balanced-reactive-cfd-using-openfoam>Towards dynamically load-balanced reactive CFD using OpenFOAM</h2>
<div style=height:10%></div>
<p>Holger Marschall,<br>
Mohammed Elwardi Fadeli</p>
<p>12/2021</p>
</section><section>
<div style=height:10%></div>
<div class=columns-container>
<div class=col style=width:30%;float:left;padding:60px>
<img data-src=images/profile.png>
</div>
<div style=flex:2>
<div style=height:40px></div>
<section data-markdown>
<script type=text/template>
<ul>
<li>Msc. in Petroleum Engineering <!-- .element: style="font-size: 0.8em;" --></li>
<li>Maintainer of an OpenFOAM-based Reservoir Engineering Toolkit (OpenRSR) <!-- .element: class="fragment" data-fragment-index="2"  style="font-size: 0.8em;"-->
<ul>
<li>Which provides <strong>coupled solvers</strong> for Black-Oil Equations <!-- .element: class="fragment" data-fragment-index="2"  style="font-size: 0.8em;"--></li>
</ul>
</li>
<li>LFCE-certified (Linux Engineer) who likes frictions with Math problems <!-- .element: class="fragment" data-fragment-index="3"  style="font-size: 0.8em;"-->
</script></li>
</ul>
</section>
</div>
</div>
</section><section>
<h2 id=well-be-discussing->We&rsquo;ll be discussing &mldr;</h2>
<ol>
<li>Adaptive Polyhedral Mesh Refinement</li>
<li>Dynamic Load-balancing applied to chemistry and AMR</li>
</ol>
</section><section>
<h1 id=native-adaptive-mesh-refinement>Native Adaptive Mesh Refinement</h1>
</section><section>
<h2 id=why-would-we-opt-for-amr>Why would we opt for AMR?</h2>
<section data-markdown>
<script type=text/template>
<ul>
<li><strong>Dynamically</strong> densify the mesh in regions of interest (only) to increase solution accuracy
<ul>
<li>Uniformly fine meshes are usually expensive <!-- .element: class="fragment" data-fragment-index="2"  style="font-size: 0.8em;"--></li>
</ul>
</li>
<li>Coarsen the mesh in other regions to save computation time <!-- .element: class="fragment" data-fragment-index="3" -->
<ul>
<li>Regions where no critical flow features are developing <!-- .element: class="fragment" data-fragment-index="3"  style="font-size: 0.8em;"-->
</script></li>
</ul>
</li>
</ul>
</section>
</section><section>
<ul>
<li>Potential for unattended and cheap accuracy increase:
<ol>
<li>Start solving on coarse mesh</li>
<li>Compute discretization errors</li>
<li>Refine where errors are high</li>
<li>Repeat 1-3 until errors fall under a certain tolerance value</li>
<li>Pass to the next time step</li>
</ol>
</li>
</ul>
</section><section>
<section data-noproecess>
<h3> Geometric Multi-grid methods vs. AMR</h3>
<div class=tikz>
<script type=text/tikz>
\begin{tikzpicture}[every node/.style={scale=0.5}]
    \usetikzlibrary{positioning}
    \begin{scope}[
            yshift=-83,every node/.append style={
            yslant=0.5,xslant=-1},yslant=0.5,xslant=-1
            ]
        \fill[white,fill opacity=0.9] (0,0) rectangle (5,5);
        \draw[step=4mm, black] (0,0) grid (5,5); %defining grids
        %\draw[step=1mm, red!50,thin] (3,1) grid (4,2);  %Nested Grid
        \draw[black,very thick] (0,0) rectangle (5,5);%marking borders
        %\fill[red] (0.05,0.05) rectangle (0.35,0.35);
    \end{scope}
<pre><code>\begin{scope}[
        yshift=0,every node/.append style={
        yslant=0.5,xslant=-1},yslant=0.5,xslant=-1
        ]
    \fill[white,fill opacity=0.9] (0,0) rectangle (5,5);
    \draw[step=6mm, black] (0,0) grid (5,5); %defining grids
    %\draw[step=1mm, red!50,thin] (3,1) grid (4,2);  %Nested Grid
    \draw[black,very thick] (0,0) rectangle (5,5);%marking borders
    %\fill[red] (0.05,0.05) rectangle (0.35,0.35);
\end{scope}

\begin{scope}[
	yshift=90,every node/.append style={
	yslant=0.5,xslant=-1},yslant=0.5,xslant=-1
	             ]
    \fill[white,fill opacity=0.9] (0,0) rectangle (5,5);
    \draw[step=10mm, black] (0,0) grid (5,5); %defining grids
    %\draw[step=1mm, red!50,thin] (3,1) grid (4,2);  %Nested Grid
    \draw[black,very thick] (0,0) rectangle (5,5);%marking borders
    %\fill[red] (0.05,0.05) rectangle (0.35,0.35);
\end{scope}
	
\begin{scope}[
        yshift=-83, xshift=500,every node/.append style={
        yslant=0.5,xslant=-1},yslant=0.5,xslant=-1
        ]
    \fill[white,fill opacity=0.9] (0,0) rectangle (5,5);
    \draw[step=10mm, black] (0,0) grid (5,5); %defining grids
    \draw[step=5mm, green!50!black] (1,1) grid (4,3);  %Nested Grid
    \draw[step=2.5mm, red] (3,1) grid (4,2);  %Nested Grid
    \draw[black,very thick] (0,0) rectangle (5,5);%marking borders
    %\fill[red] (0.05,0.05) rectangle (0.35,0.35);
\end{scope}

\begin{scope}[
	yshift=90, xshift=500, every node/.append style={
	yslant=0.5,xslant=-1},yslant=0.5,xslant=-1
	             ]
    \fill[white,fill opacity=0.9] (0,0) rectangle (5,5);
    \draw[step=10mm, black] (0,0) grid (5,5); %defining grids
    %\draw[step=1mm, red!50,thin] (3,1) grid (4,2);  %Nested Grid
    \draw[black,very thick] (0,0) rectangle (5,5);%marking borders
    %\fill[red] (0.05,0.05) rectangle (0.35,0.35);
\end{scope}
	

\draw[-latex,thick,draw=green!50!black](5.8,-.3) node[right,color=white]{Fine\hspace{3cm}mesh}
    to[out=180,in=90] (3.9,-1);
\draw[-latex,thick,draw=green!50!black] (6.2,2) node[right,color=white]{Finer\hspace{4.5cm}mesh}
     to[out=180,in=90] (4,2);
\draw[-latex,thick,draw=green!50!black](5.9,5) node[right,color=white] (coarse) {Coarse\hspace{5cm}mesh}
    to[out=180,in=90] (3.6,5);
\draw[-latex,thick,draw=green!50!black](11.2,5) to[out=0,in=90] (14,5);
\draw[-latex,thick,draw=green!50!black](10.2,-.3) to[out=0,in=90] (14,-1);
</code></pre>
<p>\end{tikzpicture}
</script></p>
</div>
</section>
</section><section>
<h3 id=success-stories-when-it-works>Success stories, when it works</h3>
<ul>
<li>10x Speedup for Adaptive Mesh Fluid Simulations on GPU, <a href=https://arxiv.org/pdf/0910.5547.pdf>P. Weng et al. (2009)</a></li>
<li>8x Speedup for Shock Hydrodynamics, <a href=https://crd.lbl.gov/assets/pubs_presos/AMCS/ANAG/A113.pdf>Berger and Colella (1988)</a></li>
</ul>
</section><section>
<h2 id=whats-already-available>What&rsquo;s already available?</h2>
<ul>
<li>OpenFOAM has a mature Hex-based adaptive refinement engine</li>
<li>Professors Jasak & Vuko have laid the foundation for polyhedral adaptive refinement
in Foam-Extend 4, nextRelease branch</li>
</ul>
</section><section>
<h2 id=what-were-bringing-to-the-table>What we’re bringing to the table?</h2>
<ul>
<li>Native multi-criteria refinement & unrefinement for polyhedral meshes
<ul>
<li>Built on top of Foam-Extend&rsquo;s engine</li>
<li>With support for cell-count based Load Balancing</li>
</ul>
</li>
</ul>
</section>
<section data-noprocess data-shortcode-slide data-background-color=white>
<h3 id=interface-tracking-refinement-br15k-cells-initial-mesh-85k>Interface-tracking refinement <br>(15k cells, initial mesh: 8.5k)</h3>
<img style=width:90%;margin:0;padding:0;position-top:0 data-src=images/alpha1.png>
</section><section>
<p style=text-align:center>Interface-tracking refinement</p>
<section data-auto-animate data-auto-animate-unmatched=false>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=1-3,5,7>

<span class=hljs-title>dynamicFvMesh</span> dynamicPolyRefinementFvMesh<span class=hljs-punctuation>;</span>
<span class=hljs-type>dynamicRefineFvMeshCoeffs</span> <span class=hljs-punctuation>{</span>
    <span class=hljs-comment>// 1. Global refinement settings</span>
    ...
    <span class=hljs-comment>// 2. Refinements description</span>
    ...
<span class=hljs-punctuation>}</span>

</code></pre>
</section>
<section data-auto-animate data-auto-animate-unmatched=false>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=3-10>

<span class=hljs-title>dynamicFvMesh</span> dynamicPolyRefinementFvMesh<span class=hljs-punctuation>;</span>
<span class=hljs-type>dynamicRefineFvMeshCoeffs</span> <span class=hljs-punctuation>{</span>
    <span class=hljs-comment>// 1. Global refinement settings</span>
    <span class=hljs-comment>// When to refine and unrefine</span>
    <span class=hljs-title>refineInterval</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
    <span class=hljs-title>unrefineInterval</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
    <span class=hljs-comment>// Stop refinining after reaching a certain level</span>
    <span class=hljs-title>maxRefinementLevel</span> <span class=hljs-number>3</span><span class=hljs-punctuation>;</span>
    <span class=hljs-comment>// Do refinement and refinement separately?</span>
    <span class=hljs-title>separateUpdates</span> <span class=hljs-keyword>false</span><span class=hljs-punctuation>;</span>
    <span class=hljs-comment>// 2. Refinements description</span>
    ...
<span class=hljs-punctuation>}</span>

</code></pre>
</section>
<section data-auto-animate data-auto-animate-unmatched=false>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=5-11>

<span class=hljs-title>dynamicFvMesh</span> dynamicPolyRefinementFvMesh<span class=hljs-punctuation>;</span>
<span class=hljs-type>dynamicRefineFvMeshCoeffs</span> <span class=hljs-punctuation>{</span>
    <span class=hljs-comment>// 1. Global refinement settings</span>
    ...
    <span class=hljs-comment>// 2. Refinements description</span>
    <span class=hljs-title>refinements</span> <span class=hljs-punctuation>(</span>
        basedOnAlpha1 <span class=hljs-punctuation>{</span>
            ...
        <span class=hljs-punctuation>}</span>
        <span class=hljs-comment>// More refinement/unrefinement operations</span>
    <span class=hljs-punctuation>)</span><span class=hljs-punctuation>;</span>
<span class=hljs-punctuation>}</span>

</code></pre>
</section>
<section data-auto-animate data-auto-animate-unmatched=false>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=7-12,14>

<span class=hljs-title>dynamicFvMesh</span> dynamicPolyRefinementFvMesh<span class=hljs-punctuation>;</span>
<span class=hljs-type>dynamicRefineFvMeshCoeffs</span> <span class=hljs-punctuation>{</span>
    <span class=hljs-comment>// 1. Global refinement settings</span>
    ...
    <span class=hljs-comment>// 2. Refinements description</span>
    <span class=hljs-title>refinements</span> <span class=hljs-punctuation>(</span>
        basedOnAlpha1 <span class=hljs-punctuation>{</span>
            <span class=hljs-comment>// Individual settings</span>
            <span class=hljs-title>refineInterval</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
            <span class=hljs-title>unrefineInterval</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
            <span class=hljs-title>maxRefinementLevel</span> <span class=hljs-number>3</span><span class=hljs-punctuation>;</span>
            <span class=hljs-title>separateUpdates</span> <span class=hljs-keyword>false</span><span class=hljs-punctuation>;</span>
            ...
        <span class=hljs-punctuation>}</span>
        <span class=hljs-comment>// More refinement/unrefinement operations</span>
    <span class=hljs-punctuation>)</span><span class=hljs-punctuation>;</span>
<span class=hljs-punctuation>}</span>

</code></pre>
</section>
<section data-auto-animate data-auto-animate-unmatched=false>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=7,10-18>

<span class=hljs-title>dynamicFvMesh</span> dynamicPolyRefinementFvMesh<span class=hljs-punctuation>;</span>
<span class=hljs-type>dynamicRefineFvMeshCoeffs</span> <span class=hljs-punctuation>{</span>
    <span class=hljs-comment>// 1. Global refinement settings</span>
    ...
    <span class=hljs-comment>// 2. Refinements description</span>
    <span class=hljs-title>refinements</span> <span class=hljs-punctuation>(</span>
        basedOnAlpha1 <span class=hljs-punctuation>{</span>
            <span class=hljs-comment>// Individual settings</span>
            ...
            <span class=hljs-comment>// Cell selection</span>
            <span class=hljs-type>refinementSelection</span> <span class=hljs-punctuation>{</span>
                <span class=hljs-title>type</span>           interfaceRefinement<span class=hljs-punctuation>;</span>
                <span class=hljs-title>fieldNames</span>     <span class=hljs-punctuation>(</span> alpha1 <span class=hljs-punctuation>)</span><span class=hljs-punctuation>;</span> 
                <span class=hljs-title>innerRefLayers</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
                <span class=hljs-title>outerRefLayers</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
                <span class=hljs-title>cellPointCellSmoothing</span> <span class=hljs-keyword>on</span><span class=hljs-punctuation>;</span>
            <span class=hljs-punctuation>}</span>
        <span class=hljs-punctuation>}</span>
        <span class=hljs-comment>// More refinement/unrefinement operations</span>
    <span class=hljs-punctuation>)</span><span class=hljs-punctuation>;</span>
<span class=hljs-punctuation>}</span>

</code></pre>
</section>
</section><section>
<h3 id=more-refinementunrefinement-criteria>More refinement/unrefinement criteria</h3>
<p>In addition to the interface refinement criterion, we can track:</p>
<ul>
<li>The discretisation error</li>
<li>Interesting ranges of field <em>values, gradient</em> and/or <em>curl</em></li>
<li>User-supplied (dynamic) code for refinement selection</li>
</ul>
</section><section>
<p>There is also support for ”<strong>mounting</strong>” these criteria on top of each other</p>
<ul>
<li>Unrefinement won’t interfere with the refined (and to-be refined) cells in the same timeStep</li>
</ul>
</section><section>
<h3 id=user-supplied-code-for-refinement-selection>User-supplied code for refinement selection</h3>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=1-6|9-15|17-29|31-43|45-51|54-56>

<span class=hljs-type>refineBasedOnResiduals</span>
<span class=hljs-punctuation>{</span>
    <span class=hljs-title>refineInterval</span>   <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
    <span class=hljs-title>unrefineInterval</span> <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
    <span class=hljs-title>maxRefinementLevel</span>   <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
    <span class=hljs-title>separateUpdates</span> <span class=hljs-keyword>false</span><span class=hljs-punctuation>;</span>

    <span class=hljs-comment>// Refinement selection criteria</span>
    <span class=hljs-type>refinementSelection</span>
    <span class=hljs-punctuation>{</span>
        <span class=hljs-title>type</span>        codedFieldBoundsRefinement<span class=hljs-punctuation>;</span>
        <span class=hljs-title>fieldName</span>   magResError<span class=hljs-punctuation>;</span>
        <span class=hljs-title>lowerBound</span>  <span class=hljs-number>0</span><span class=hljs-punctuation>;</span>
        <span class=hljs-title>upperBound</span>  <span class=hljs-number>1</span><span class=hljs-punctuation>;</span>
        <span class=hljs-title>cellPointCellSmoothing</span> <span class=hljs-keyword>on</span><span class=hljs-punctuation>;</span>

        <span class=hljs-title>codeInclude</span>
        <span class=hljs-punctuation>#{</span>
            #include "errorEstimate.H"
            #include "resError.H"
<span class=hljs-punctuation>        #}</span><span class=hljs-punctuation>;</span>
        <span class=hljs-title>codeLibs</span>
        <span class=hljs-punctuation>#{</span>
            -lerrorEstimation
<span class=hljs-punctuation>        #}</span><span class=hljs-punctuation>;</span>
        <span class=hljs-title>codeOptions</span>
        <span class=hljs-punctuation>#{</span>
            -I$(LIB_SRC)/errorEstimation/lnInclude
<span class=hljs-punctuation>        #}</span><span class=hljs-punctuation>;</span>

        <span class=hljs-title>code</span>
        <span class=hljs-punctuation>#{</span>
            // Return immediately if 1st timeStep,
            if (mesh().time().timeIndex() <= 1)
            {
                return labelList().xfer();
            }
            // Get refs to involved fields
            const auto& phi = mesh().lookupObject<surfacescalarfield>("phi");
            const auto& U = mesh().lookupObject<volvectorfield>("U");
            const auto& nu = mesh().lookupObject<volscalarfield>("nu");
            const auto& p = mesh().lookupObject<volscalarfield>("p");
            const auto& rho = mesh().lookupObject<volscalarfield>("rho");

            // Estimate the error vector
            errorEstimate<vector> ee
            (
                resError::div(phi, U)
                - resError::laplacian(nu, U)
                + fvc::grad(p/rho)
            );
            volScalarField magResError = mag(ee.error());
            scalar maxResErr = gMax(magResError);
            field_.internalField() = magResError.internalField();   
            lowerBound_ = 0.8 * maxResErr;
            upperBound_ = maxResErr;
<span class=hljs-punctuation>        #}</span><span class=hljs-punctuation>;</span>
    <span class=hljs-punctuation>}</span>
<span class=hljs-punctuation>}</span>

</code></pre>
</section>
<section data-noprocess data-shortcode-slide data-background-color=white>
<h3 id=multi-criteria-refinement-process-per-timestep>Multi-Criteria Refinement process (per timeStep)</h3>
<section data-transition=fade-out>
<img style=scale:.85 data-src=images/17.png>
</section>
<section data-transition="fade-in fade-out">
<img style=scale:.85 data-src=images/18.png>
</section>
<section data-transition="fade-in fade-out">
<img style=scale:.85 data-src=images/19.png>
</section>
</section><section>
<h3 id=multi-criteria-refinement-process-per-timestep-1>Multi-Criteria Refinement process (per timeStep)</h3>
<script type=text/javascript>var items=[{type:"text",title:"Cell Level 0",description:"Initial cell size",position:{left:170,top:90}},{type:"text",title:"Cell Level 1",description:"",position:{left:185,top:180}},{type:"text",title:"Cell Level 2",description:"",position:{left:250,top:155}},{type:"text",title:"Cell Level 3",description:"Max refinement level",position:{left:350,top:170}}],options={allowHtml:!0};$(document).ready(function(){$("#my-interactive-image").interactiveImage(items,options)})</script>
<div id=my-interactive-image style=margin:auto;width:800px;height:463px;border-radius:8px;background-size:cover;background-image:url(images/levels.png)></div>
</section><section>
<h1 id=load-balancing>Load Balancing</h1>
</section><section>
<h3 id=load-balance-the-mesh-after-topology-changes>Load-Balance the mesh after topology changes</h3>
<ul>
<li>
<p>Refinement methods generally &ldquo;unbalance&rdquo; local regions,
generating load balancing issues.</p>
</li>
<li>
<p>The Load-Balancer engine in Foam-Extend can auto-sense processor
imbalance with respect to cell-count</p>
<ul>
<li>Using a trigger coefficient</li>
</ul>
</li>
<li>
<p>It also tries to migrates adjacent cells between processors if possible</p>
</li>
</ul>
</section><section>
<pre class=code-wapper data-id=code-animation><code class="language-foam hljs" data-trim data-noescape data-auto-animate data-line-numbers=1-3,13|4|5-12>

<span class=hljs-title>dynamicFvMesh</span> loadBalanceDynamicPolyRefinementFvMesh<span class=hljs-punctuation>;</span>
<span class=hljs-type>loadBalanceFvMeshCoeffs</span>
<span class=hljs-punctuation>{</span>
    <span class=hljs-title>imbalanceTrigger</span> <span class=hljs-number>0.2</span><span class=hljs-punctuation>;</span>
    <span class=hljs-title>numberOfSubdomains</span> <span class=hljs-number>4</span><span class=hljs-punctuation>;</span>
    <span class=hljs-title>method</span>          hierarchical<span class=hljs-punctuation>;</span>
    <span class=hljs-type>hierarchicalCoeffs</span>
    <span class=hljs-punctuation>{</span>
        <span class=hljs-title>n</span>       <span class=hljs-punctuation>(</span> <span class=hljs-number>1</span> <span class=hljs-number>2</span> <span class=hljs-number>2</span> <span class=hljs-punctuation>)</span><span class=hljs-punctuation>;</span>
        <span class=hljs-title>delta</span>   <span class=hljs-number>0.001</span><span class=hljs-punctuation>;</span>
        <span class=hljs-title>order</span>   xyz<span class=hljs-punctuation>;</span>
    <span class=hljs-punctuation>}</span>
<span class=hljs-punctuation>}</span>

</code></pre>
</section><section>
<h3 id=load-balance-chemistry-problems>Load Balance chemistry problems</h3>
<p>What Bulut Tekgul et al. did with <strong><a href=https://github.com/Aalto-CFD/DLBFoam>DLBFoam</a></strong>:</p>
<ul>
<li>Load balance the number of <strong>Chemistry ODE problems</strong> across processes
<ul>
<li>Solved independently during each CFD iteration</li>
</ul>
</li>
<li>Employ reference solution mapping to (thermo-chemically) similar cells</li>
</ul>
</section><section>
<p style=text-align:center>An example of DLBFoam run with the Hex-based adaptive refinement engine (courtesy of Bulut)</p>
<video style=scale:.85;margin:0;padding:0 data-autoplay src=/videos/dlbfoam.mp4></video>
</section><section>
<h1 id=next-steps>Next steps</h1>
<ul>
<li>Algebraic form of AMR
<ul>
<li>Run AMR with Multi-Grid solvers fully algebraically?</li>
</ul>
</li>
</ul>
</section>
</div>
</div>
<script type=application/json id=reveal-hugo-site-params>{"custom_css":"/stylesheets/custom.css","highlight_theme":"dracula","width":"1200"}</script>
<script type=application/json id=reveal-hugo-page-params>null</script>
<script src=/amr-lb/reveal-js/reveal.js></script>
<script type=text/javascript src=/amr-lb/reveal-js/plugin/markdown/markdown.js></script>
<script type=text/javascript src=/amr-lb/reveal-js/plugin/highlight/highlight.js></script>
<script type=text/javascript src=/amr-lb/reveal-js/plugin/zoom/zoom.js></script>
<script type=text/javascript src=/amr-lb/reveal-js/plugin/notes/notes.js></script>
<script type=text/javascript>var revealHugoDefaults,revealHugoSiteParams,revealHugoPageParams,options;function camelize(a){return a&&Object.keys(a).forEach(function(b){newK=b.replace(/(\_\w)/g,function(a){return a[1].toUpperCase()}),newK!=b&&(a[newK]=a[b],delete a[b])}),a}revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML),revealHugoPageParams=JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML),options=Object.assign({plugins:[RevealZoom,RevealNotes,RevealMarkdown,RevealHighlight]},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams)),Reveal.initialize(options)</script>
</body>
</html>